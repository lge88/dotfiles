#!/usr/bin/env node
var path = require('path');
var fs = require('fs');
var join = path.join;
var resolve = path.resolve;
var prog = require('commander');
var extend = require('underscore').extend;
var mustache = require('mustache');
require('shelljs/global');

var tmplRoot = resolve(__dirname, '..', '.templates');

prog
  .version('0.0.1')
  .usage('path')
  .option('-i, --interactive', 'Initialize the workspace interactively')
  .option('-p, --port <port>', 'The port for this workspace, default is smallest port available that >= 8005')
  .option('-t, --template <template>', 'Initialize the workspace with template')
  .option('-l, --list [template]', 'List all available templates')
  .option('-v, --verbose', 'List contents of the temlate')
  .option('-a, --add-template <path>', 'Add <path> as a new template')
  .option('-f, --force', 'Override existing directory');

prog.parse(process.argv);

if (prog.list) {
  var list = prog.verbose ? ls('-R', tmplRoot) : ls(tmplRoot);
  list.forEach(function(p) {
    echo(p);
  });
  exit(0);
}

var args = prog.args;
if (!args[0]) {
  echo('Missing required argument arg1!');
  exit(1);
}

var pkgName = path.basename(args[0]);
var dest = resolve(pkgName);

var tmpl = prog.template || "node-component";
var tmplPath = resolve(tmplRoot, tmpl);
var tmplFilePattern = /(^Makefile|.*\.(js|json|txt|html|jade|mustache))$/;

// local variable is passed in the mustache render engine.
var local = {
  pkgName: pkgName,
  port: prog.port || 8005
};

if (test('-e', dest) && !prog.force) {
  echo('The directory ' + dest + ' already exists! Use -f flag if you want to override it.');
  exit(1);
} else {
  
  if (!test('-e', tmplPath)) {
    echo('Can not found template ' + tmpl + ', quit.');
    exit(1);
  }
  
  generateByTemplate(tmplPath, local);
  echo('Done!');
  exit(0);
}

function getPermission(file) {
  return parseInt(fs.statSync(file).mode.toString(8), 10).toString().slice(-3);
}

function generateByTemplate(p, data) {
  mkdir(dest);
  cd(dest);

  // Get all the paths;
  var paths = ls('-R', p);

  // Creating subdirectory tree;
  paths.filter(function(p) {
    return fs.statSync(join(tmplPath, p)).isDirectory();
  }).forEach(function(p) {
    try {
      p = mustache.render(p, data);
    } catch(err) {
      echo('Mustache can not render string ' + p, err);
      exit(1);
    }
    echo('Creating directory:' + p);
    mkdir('-p', p);
  });
  
  // Generate files;
  paths.filter(function(p) {
    return fs.statSync(join(tmplPath, p)).isFile();
  }).forEach(function(file) {

    var perm = getPermission(join(tmplPath, file));
    try {
      var newFileName = mustache.render(file, data);
    } catch(err) {
      echo('Mustache can not render string ' + file, err);
      exit(1);
    }

    // We simply copy the file to destination if the file does not
    // match the valid template pattern
    if (!file.match(tmplFilePattern)) {
      echo('Copying file: ' + newFileName);
      cp('-f', join(tmplPath, file), newFileName);
    } else {
      echo('Generating file: ' + newFileName);
      try {
        var str = mustache.render(cat(join(tmplPath, file)), data);
      } catch(err) {
        echo('Mustache can not render file ' + file, err);
        exit(1);
      }
      
      if (path.extname(file) === '.json') {
        try {
          JSON.stringify(JSON.parse(str), null, 2).to(newFileName);
        } catch(err) {
          echo('Invalid JSON file ' + file, err);
          exit(1);
        }
      } else {
        str.to(newFileName);
      }
    }
    
    chmod(perm, newFileName);
    
  });

}
