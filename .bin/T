#! /usr/bin/env node

require( 'shelljs/global' );
var path = require('path');
var rl = require( 'readline' ).createInterface( {
  input: process.stdin,
  output: process.stdout
} );

var tmplName = process.argv[2];
var pkgName = process.argv[3] || tmplName; // now().join( '-' );
var dest = path.resolve( pkgName );
pkgName = path.basename( pkgName );
// console.log( tmplName, pkgName );exit();


var matched = pkgName.match( /([^\/]*)\/+$/ );
if ( matched ) { pkgName = matched[1]; }

if ( !tmplName ) {
  echo( 'Usage: T [templateName:lib] [destinationPath]' );
  echo( 'Available templates:' );
  printAvailableTemplates();
  exit( 1 );
}

try {
  var src = findTemplate( tmplName );
} catch( err ) {
  console.log( err );
  exit();
}

var savedDir = pwd();

var context = {
  pkgName: pkgName,
  cwd: pwd(),
  src: src,
  dest: dest,
  filesCopied: false,
  filter: null,
  ignore: [
      /^\.git$/, /^components$/, /^node_modules$/, /backup/,
      /\.bak$/, /autosaves/, /elpa/, /legacy/, /~$/, /^\.#/
  ],
  middlewares: [],
  middlewareFolderPattern: /^_.*_$/,
  hooks:  [
    'afterCopy', 'beforeCopy',
    // legacy:
    'execute', 'run'
  ],
  routes: null,
  copyList: []
};

if ( test( '-e', dest ) ) {
  rl.question( dest + ' is already there, Override? [y/N]', function( ans ) {
    if ( ans === 'y' ) {
      echo( 'OK, doit' );
      run( context );
    } else {
      echo( 'Abort.' );
      exit();
    }
  } );
} else {
  run( context );
}

function initRoutes( context ) {
  var middlewares = context.middlewares, hooks = context.hooks;
  var cwd = context.cwd, dest = context.dest;
  function resetToCwd() { cd( cwd ); }
  function resetToDest() { cd( dest ); }

  function handlerWrapper( handler, p ) {
    var reset;
    if ( p.route === 'beforeCopy' ) {
      reset = resetToCwd;
    } else {
      reset = resetToDest;
    }
    var wrapped = function() {
      reset();
      handler( context );
      return context;
    };
    wrapped.order = handler.order;
    return wrapped;
  }

  context.routes = compileRoutes( hooks, middlewares, handlerWrapper );
}

function prog() {

  var stack =  Array.prototype.slice.call( arguments );
  var _compiled;

  ( typeof stack[0] === 'string' ) && ( p.route = stack.shift() );
  ( stack.length === 1 ) && Array.isArray( stack[0] ) && ( stack = stack[ 0 ] );

  function p() {
    p.dirty && ( _compiled = p.compile( p.stack ) ) && ( p.dirty = false );
    return _compiled.apply( this, arguments );
  }

  p.dirty = true;
  p.clone = clone;
  p.stack = stack;
  p.noop = noop;
  p.compile = compile;
  compile.comparator = byOrder;

  function compile( stack ) {
    return stack
      .slice()
      .filter( function( f ) { return f !== p.noop; } )
      .map( function( f ) {
        isNaN( f.order ) && ( f.order = 0 );
        return f;
      } )
      .sort( compile.comparator )
      .reduce( function( sofar, f ) {
        return function( x ) { return f( sofar(x) ); };
      }, p.noop );
  };

  function noop( x ) { return x; }
  function byOrder( a, b ) { return a.order - b.order; };
  function clone() { return prog( p.route, p.stack ); }

  return p;
};

function compileRoutes( routes, middlewares, handlerWrapper ) {

  handlerWrapper || ( handlerWrapper = function( handler, program ) {
    return handler;
  } );

  var programs = routes
    .map( function( route ) {
      var p = prog( route );
      return p;
    } );

  middlewares
    .filter( function( middleware ) {
      return !(middleware.disabled === true);
    } )
    .forEach( function( middleware ) {
      programs
        .map( function( p ) {
          var route = p.route;
          return [ p, middleware[route] ];
        } )
        .filter( function( tuple ) {
          var handler = tuple[1];
          return (typeof handler !== 'undefined') && !(handler.disabled === true);
        } )
        .map( function( tuple ) {
          ( !Array.isArray( tuple[1] ) ) && ( tuple[1] = [ tuple[1] ] );
          return tuple;
        } )
        .forEach( function( tuple ) {
          var handlers = tuple[1], program = tuple[0];
          handlers
            .filter( function( handler ) {
              return typeof handler === 'function' ;
            } )
            .map( function( handler ) {
              return handlerWrapper( handler, program );
            } )
            .forEach( function( handler ) {
              program.stack.push( handler );
            } );
          program.dirty = true;
        } );
    } );

  return programs.reduce( function( prev, cur ) {
    prev[cur.route] = cur;
    return prev;
  }, {} );

}

function loadMiddlewares( context ) {
  var src = context.src, middlewares = context.middlewares;
  var middlewareFolderPattern = context.middlewareFolderPattern;

  ls( src )
    .filter( function( f ) {
      return middlewareFolderPattern.test( f );
    } )
    .map( function( dir ) {
      return path.resolve( src, dir );
    } )
    .filter( function( dir ) {
      return test( '-d', dir );
    })
    .forEach( function( dir ) {
      echo( 'load middleware under ' + dir +' folder' );
      ls( dir )
        .filter( function( f ) {
          return /\.js$/.test( f );
        } )
        .filter( function( f ) {
          try {
            require( path.resolve( dir, f ) );
          } catch( err ) {
            console.log( err );
            return false;
          }
          return true;
        } )
        .map( function( f ) {
          return require( path.resolve( dir, f ) );
        } )
        .forEach( function( middleware ) {
          middlewares.push( middleware );
        } );
    } );

}

function walk( dir, filterFn, list ) {
  filterFn || ( filterFn = function() { return true; } );
  list || ( list = [] );
  ls( '-A', dir )
    .filter( filterFn )
    .map( function( f ) {
      return path.join( dir, f );
    } )
    .forEach( function( f ) {
      if ( test( '-d', f ) ) {
        walk( f, filterFn, list );
      } else {
        list.push( f );
      }
    } );
  return list;
}

function generateCopyList( context ) {
  var src = context.src, dest = context.dest;
  var filterFn;
  if ( typeof context.filter === 'function' ) {
    filterFn = context.filter;
  } else {
    var patternsToIgnore = context.ignore;
    filterFn = function( f ) {
      return !patternsToIgnore.some( function( p ) {
        return p.test( f );
      } );
    };
  }

  var files = walk( src, filterFn );

  context.copyList = files.map( function( file ) {
    var a = path.resolve( src, file );
    var relPath = path.relative( src, a );
    var b = path.resolve( dest, relPath );
    return [ a, b ];
  } );

}

function runPreInitTasks( context ) {
  var handler = context.routes.beforeCopy;
  handler( context );
}

function copyFiles( context ) {
  var copyList = context.copyList;
  var src = context.src, dest = context.dest;

  echo( 'Copy template files from ' + src );

  copyList.forEach( function( pair ) {
    var src = pair[0], dest = pair[1];
    var dir = path.dirname( dest );
    mkdir( '-p', dir );
    cp( '-f', src, dest );
  } );
  context.filesCopied = true;
  echo( 'Files are copied to ' + dest );
}

function runPostInitTasks( context ) {
  var handler = context.routes.afterCopy;
  // console.log( context );
  handler( context );
  // console.log( context );
}

function run( context ) {
  if ( test( '-f', context.src ) ) {
    cp( context.src, context.dest );
    exit();
  }
  loadMiddlewares( context );
  initRoutes( context );
  runPreInitTasks( context );
  generateCopyList( context );
  copyFiles( context );
  runPostInitTasks( context );
  exit();
}

function getTemplatePaths() {
  var home = process.env.HOME;
  var tmplPaths = process.env.TMPL_PATH || [
    home + '/.dotfiles/.templates',
    home + '/Develop/js/ise/templates'
  ].join( ':' );

  tmplPaths = tmplPaths.trim().split( ':' )
    .map( function( p ) { return path.resolve( p ); } )
    .filter( function( p ) {
      return test( '-d', p );
    } );
  return tmplPaths;
}

function findTemplate( name ) {
  var found = null, paths = getTemplatePaths();
  paths.some( function( p ) {
    return ls( p )
      .filter( function( d ) {
        return test( '-e', path.resolve( p, d )  );
      } )
      .filter( function( d ) {
        return !/(legacy|\.bak$)/.test( d );
      } )
      .some( function( file ) {
        if ( file === name ) {
          found = path.resolve( p, name );
          return true;
        } else {
          return false;
        }
      } );
  } );

  if ( !found ) {
    var p = path.resolve( name );
    if ( test( '-d', p ) ) {
      found = p;
    }
  }

  if ( !found ) {
    throw "Can't find template " + name + " in:\n " + paths.join( '\n' );
  }
  return found;
}

function printAvailableTemplates() {
  var paths = getTemplatePaths();
  paths
    .forEach( function( p ) {
      ls( p )
        .filter( function( d ) {
          return test( '-d', path.resolve( p, d )  );
        } )
        .filter( function( d ) {
          return !/(legacy|\.bak$)/.test( d );
        } )
        .forEach( function( folder ) {
          console.log( folder );
        } );
    } );
}

function now() {
  var d = new Date();
  var out = [
    1 + d.getMonth(),
    d.getDate(),
    d.getHours(),
    d.getMinutes(),
    d.getSeconds()
  ].map( function( num ) {
    return ( '0' + num ).slice( -2 );
  } );
  out.unshift( '' + d.getFullYear() );
  return out;
}
